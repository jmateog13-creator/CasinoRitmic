<!DOCTYPE html>
<html lang="ca">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El Ganxo del Virtu√≥s</title>
    <style>
        :root {
            --neon-pink: #ff00ff;
            --neon-blue: #00ffff;
            --dark-bg: #1a1a1a;
            --metal: #333;
            --gold: #ffd700;
        }

        /* Instructions Modal */
        #instructions-modal {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .instr-content {
            background: #1a0505;
            padding: 40px;
            border: 4px double var(--gold);
            text-align: center;
            max-width: 600px;
            color: #fff;
            position: relative;
        }

        .instr-close {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #aaa;
            font-size: 2rem;
            cursor: pointer;
        }

        .instr-btn {
            padding: 10px 30px;
            font-size: 1.2rem;
            background: var(--gold);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #1a0505;
            margin-top: 20px;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
        }

        /* Arcade Cabinet Frame */
        #cabinet {
            position: relative;
            width: 1000px;
            /* Increased from 800px */
            height: 95vh;
            background: linear-gradient(to right, #222, #444, #222);
            border: 20px solid #111;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Marquee */
        #marquee {
            width: 100%;
            text-align: center;
            background: #000;
            border: 4px solid var(--neon-pink);
            border-radius: 10px;
            margin-bottom: 10px;
            box-shadow: 0 0 15px var(--neon-pink);
        }

        h1 {
            margin: 10px;
            font-size: 2.5rem;
            color: #fff;
            text-shadow: 0 0 10px var(--neon-pink), 0 0 20px var(--neon-pink);
            letter-spacing: 5px;
        }

        /* Game Area */
        #game-container {
            position: relative;
            width: 900px;
            /* Increased from 700px */
            height: 600px;
            /* Increased from 500px */
            background: #111;
            border: 5px solid var(--neon-blue);
            border-radius: 5px;
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.8);
        }

        canvas {
            display: block;
        }

        /* UI Panel */
        #ui-panel {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding: 10px;
            background: #222;
            border-top: 2px solid #555;
            border-radius: 0 0 10px 10px;
        }

        .stat-box {
            text-align: center;
            background: #000;
            padding: 10px 20px;
            border: 2px solid var(--gold);
            border-radius: 5px;
            min-width: 100px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
            display: block;
        }

        .stat-value {
            font-size: 1.5rem;
            color: var(--gold);
            font-weight: bold;
        }

        #target-display {
            font-size: 1.2rem;
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        /* Controls */
        #controls {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .btn {
            background: #333;
            color: white;
            border: 2px solid #555;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 5px 0 #111;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #111;
        }

        #btn-drop {
            background: #ff0033;
            border-color: #cc0000;
            border-radius: 10px;
            width: 150px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        /* Volume Control - Bottom Left */
        .volume-control {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 20px;
            border: 1px solid var(--gold);
        }

        .volume-control span {
            font-size: 1.5rem;
        }

        input[type=range] {
            width: 100px;
            accent-color: var(--gold);
        }

        /* Menu Button - Top Right */
        #btn-menu {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid var(--gold);
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            text-decoration: none;
            font-weight: bold;
            z-index: 1000;
            transition: background 0.2s;
        }

        #btn-menu:hover {
            background: rgba(255, 215, 0, 0.2);
        }

        /* Modals */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .modal-content {
            background: linear-gradient(135deg, #222, #111);
            padding: 40px;
            border-radius: 20px;
            border: 4px solid var(--gold);
            text-align: center;
            max-width: 500px;
            box-shadow: 0 0 50px var(--gold);
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .relic-icon {
            font-size: 5rem;
            margin: 20px 0;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.5));
        }

        .action-btn {
            background: var(--gold);
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s;
        }

        .action-btn:hover {
            transform: scale(1.1);
        }
    </style>
</head>

<body>

    <div id="ui-bar">
        <a href="menu.html" class="btn-menu">üè† MEN√ö</a>
    </div>

    <!-- Instructions Modal -->
    <div id="instructions-modal">
        <div class="instr-content">
            <span class="instr-close"
                onclick="document.getElementById('instructions-modal').style.display='none'">√ó</span>
            <h2 style="color: var(--gold);">COM JUGAR</h2>
            <p style="font-size:1.2rem;">Mou el ganxo per atrapar la figura musical que se't demana.</p>
            <p>Tens un temps l√≠mit per aconseguir-ho!</p>
            <button class="instr-btn"
                onclick="document.getElementById('instructions-modal').style.display='none'">JUGAR</button>
        </div>
    </div>
    <div id="cabinet">
        <div id="marquee">
            <h1>EL GANXO DEL VIRTU√ìS</h1>
        </div>

        <div id="game-container">
            <canvas id="gameCanvas" width="900" height="600"></canvas>
        </div>

        <div id="ui-panel">
            <div class="stat-box">
                <span class="stat-label">TEMPS</span>
                <span class="stat-value" id="timer">60</span>
            </div>
            <div style="text-align: center; flex-grow: 1;">
                <span class="stat-label">OBJECTIU ACTUAL</span>
                <div id="target-display">TROBA: <span id="target-name"
                        style="color: var(--gold); font-weight: bold;">...</span></div>
            </div>
            <div class="stat-box">
                <span class="stat-label">RESCATATS</span>
                <span class="stat-value" id="score">0/5</span>
            </div>
        </div>

        <div id="controls">
            <button class="btn" id="btn-left">‚¨ÖÔ∏è</button>
            <button class="btn" id="btn-drop">BAIXAR GANXO</button>
            <button class="btn" id="btn-right">‚û°Ô∏è</button>
        </div>
    </div>

    <div class="volume-control">
        <button id="mute-btn" onclick="game.toggleMute()"
            style="background:none; border:none; font-size: 1.5rem; cursor: pointer;">üîä</button>
        <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.5">
    </div>

    <div id="start-screen" class="modal" style="display: flex;">
        <div class="modal-content">
            <h1 style="color: var(--neon-pink);">EL GANXO DEL VIRTU√ìS</h1>
            <p>Demostra la teva precisi√≥ visual!</p>
            <p>Rescata 5 figures musicals correctes abans que s'acabi el temps.</p>
            <button class="action-btn" onclick="game.start()">INSERIR MONEDA</button>
        </div>
    </div>

    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h2 style="color: var(--gold);">VIRTUOSISME EXTREM!</h2>
            <div class="relic-icon">üéª</div>
            <h3 style="color: var(--neon-blue);">LA CORDA TRENCADA DE PAGANINI</h3>
            <p style="font-style: italic; color: #aaa;">"Niccol√≤ Paganini tocava amb tanta passi√≥ que sovint trencava
                les cordes del seu viol√≠ i continuava tocant amb les que quedaven."</p>
            <button class="action-btn" onclick="location.reload()">TORNAR A JUGAR</button>
        </div>
    </div>

    <div id="lose-modal" class="modal">
        <div class="modal-content">
            <h2 style="color: #ff0033;">GAME OVER</h2>
            <p>S'ha acabat el temps o has fallat massa vegades.</p>
            <button class="action-btn" onclick="location.reload()">REINTENTAR</button>
        </div>
    </div>

    <audio id="bg-music" src="music/background_music_gancho.mp3" loop></audio>

    <script>
        // --- ASSETS & DATA ---
        const FIGURES = [
            { id: 'rodona', img: 'images/rodona.jpg', name: 'RODONA' },
            { id: 'blanca', img: 'images/blanca.jpg', name: 'BLANCA' },
            { id: 'negra', img: 'images/negra.jpg', name: 'NEGRA' },
            { id: 'corxera', img: 'images/corxera.jpg', name: 'CORXERA' },
            { id: 'semicorxera', img: 'images/semicorxera.jpg', name: 'SEMICORXERA' },
            { id: 's_rodona', img: 'images/silencirodona.jpg', name: 'SILENCI RODONA' },
            { id: 's_blanca', img: 'images/silenciblanca.jpg', name: 'SILENCI BLANCA' },
            { id: 's_negra', img: 'images/silencinegra.jpg', name: 'SILENCI NEGRA' },
            { id: 's_corxera', img: 'images/silencicorxera.jpg', name: 'SILENCI CORXERA' }
        ];

        // --- AUDIO ENGINE ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        const bgMusic = document.getElementById('bg-music');

        document.body.addEventListener('click', () => {
            if (bgMusic.paused) {
                bgMusic.volume = document.getElementById('volume-slider').value * 0.5;
                bgMusic.play().catch(e => console.log(e));
            }
        }, { once: true });

        document.getElementById('volume-slider').addEventListener('input', (e) => {
            bgMusic.volume = e.target.value * 0.5;
        });

        const sounds = {
            motor: null,
            win: null,
            error: null
        };

        function playTone(freq, type, duration, vol = 0.1) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            // Get current volume from slider
            let masterVolume = parseFloat(document.getElementById('volume-slider').value);
            if (game.isMuted) masterVolume = 0;

            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

            // Apply volume
            gain.gain.setValueAtTime(vol * masterVolume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function playMotor() {
            // Stop existing if running
            if (sounds.motor) {
                sounds.motor.osc.stop();
            }

            // Low hum
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            let masterVolume = parseFloat(document.getElementById('volume-slider').value);
            if (game.isMuted) masterVolume = 0;

            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(50, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.05 * masterVolume, audioCtx.currentTime);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();

            sounds.motor = { osc, gain };
            return sounds.motor;
        }

        function stopMotor() {
            if (sounds.motor) {
                sounds.motor.gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
                sounds.motor.osc.stop(audioCtx.currentTime + 0.1);
                sounds.motor = null;
            }
        }


        function playWinSound() {
            playTone(440, 'square', 0.1, 0.4);
            setTimeout(() => playTone(554, 'square', 0.1, 0.4), 100);
            setTimeout(() => playTone(659, 'square', 0.2, 0.4), 200);
        }

        function playErrorSound() {
            playTone(150, 'sawtooth', 0.3, 0.5);
            setTimeout(() => playTone(100, 'sawtooth', 0.3, 0.5), 150);
        }

        // --- PHYSICS ENGINE ---
        class Ball {
            constructor(x, y, r, data) {
                this.x = x;
                this.y = y;
                this.r = r;
                this.data = data;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = 0;
                this.mass = 1;
                this.restitution = 0.5; // Bounciness
                this.friction = 0.98;
                this.isGrabbed = false;

                // Image
                this.img = new Image();
                this.img.src = data.img;
                this.imgLoaded = false;
                this.img.onload = () => { this.imgLoaded = true; };
                this.img.onerror = () => { this.imgLoaded = false; }; // Fallback to text
            }

            update(gravity) {
                // *** FIX 1: Stop physics immediately when grabbed ***
                if (this.isGrabbed) {
                    this.vx = 0;
                    this.vy = 0;
                    return;
                }

                this.vy += gravity;
                this.x += this.vx;
                this.y += this.vy;

                // Floor collision (Raised to 450 as per "falso suelo a la altura de las segundas bolas")
                if (this.y + this.r > 450) {
                    this.y = 450 - this.r;
                    this.vy *= -this.restitution;
                    this.vx *= this.friction;
                }

                // Wall collision
                if (this.x - this.r < 0) {
                    this.x = this.r;
                    this.vx *= -this.restitution;
                }
                if (this.x + this.r > 900) { // New width
                    this.x = 900 - this.r;
                    this.vx *= -this.restitution;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Sphere look
                const grad = ctx.createRadialGradient(-this.r / 3, -this.r / 3, this.r / 10, 0, 0, this.r);
                grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                grad.addColorStop(0.3, 'rgba(200,200,255,0.5)');
                grad.addColorStop(1, 'rgba(100,100,200,0.3)');

                ctx.beginPath();
                ctx.arc(0, 0, this.r, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Content
                if (this.imgLoaded) {
                    ctx.drawImage(this.img, -this.r * 0.7, -this.r * 0.7, this.r * 1.4, this.r * 1.4);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.data.name.substring(0, 3), 0, 0);
                }

                ctx.restore();
            }
        }

        class Claw {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 40;
                this.state = 'IDLE'; // IDLE, DROPPING, GRABBING, RISING, OPENING
                this.dropSpeed = 5;
                this.riseSpeed = 3;
                this.moveSpeed = 5;
                this.cableLength = 50;
                this.maxCable = 400; // Limit drop to floor (450 - height/buffer)
                this.grabbedBall = null;
                this.openAngle = 0.5; // Radians
            }

            update(input, balls) {
                if (this.state === 'IDLE') {
                    if (input.left && this.x > 50) this.x -= this.moveSpeed;
                    if (input.right && this.x < 850) this.x += this.moveSpeed; // New width limit
                    if (input.drop) this.state = 'DROPPING';
                    this.openAngle = 0.5;
                } else if (this.state === 'DROPPING') {
                    this.cableLength += this.dropSpeed;

                    // Check collision with balls while dropping
                    const clawTipX = this.x;
                    const clawTipY = this.y + this.cableLength + this.height;

                    if (balls) {
                        for (let ball of balls) {
                            const dx = clawTipX - ball.x;
                            const dy = clawTipY - ball.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < ball.r) { // Physical Collision Check
                                // Precision Grab Check: Relaxed to full radius
                                if (dist < ball.r) {
                                    this.grabbedBall = ball;
                                    ball.isGrabbed = true;
                                    this.state = 'GRABBING';
                                    setTimeout(() => this.state = 'RISING', 500);
                                    return;
                                } else {
                                    // Hit the edge but didn't grab -> Stop drop and rise back up
                                    this.state = 'RISING';
                                    return;
                                }
                            }
                        }
                    }

                    if (this.cableLength >= this.maxCable) {
                        this.state = 'GRABBING';
                        setTimeout(() => this.state = 'RISING', 500);
                    }
                } else if (this.state === 'GRABBING') {
                    this.openAngle = 0.1; // Close claw
                } else if (this.state === 'RISING') {
                    this.cableLength -= this.riseSpeed;
                    if (this.cableLength <= 50) {
                        this.state = 'OPENING';
                        setTimeout(() => {
                            this.state = 'IDLE';
                            if (this.grabbedBall) {
                                // Check win condition
                                game.checkCatch(this.grabbedBall);
                                this.grabbedBall.isGrabbed = false;
                                this.grabbedBall = null;
                            }
                        }, 500);
                    }
                }

                // Sync grabbed ball
                if (this.grabbedBall) {
                    this.grabbedBall.x = this.x;
                    this.grabbedBall.y = this.y + this.cableLength + 20;
                    this.grabbedBall.vx = 0;
                    this.grabbedBall.vy = 0;
                }
            }

            draw(ctx) {
                // Cable
                ctx.beginPath();
                ctx.moveTo(this.x, 0);
                ctx.lineTo(this.x, this.y + this.cableLength);
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 4;
                ctx.stroke();

                // Claw Body
                const cy = this.y + this.cableLength;
                ctx.fillStyle = '#888';
                ctx.fillRect(this.x - 20, cy, 40, 20);

                // Fingers
                ctx.save();
                ctx.translate(this.x, cy + 20);

                // Left Finger
                ctx.save();
                ctx.rotate(this.openAngle);
                ctx.fillStyle = '#aaa';
                ctx.fillRect(-5, 0, 10, 40);
                ctx.beginPath();
                ctx.arc(0, 40, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Right Finger
                ctx.save();
                ctx.rotate(-this.openAngle);
                ctx.fillStyle = '#aaa';
                ctx.fillRect(-5, 0, 10, 40);
                ctx.beginPath();
                ctx.arc(0, 40, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.restore();
            }
        }

        // --- GAME LOGIC ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.balls = [];
                this.claw = new Claw(450, 20); // Center of 900
                this.gravity = 0.2;
                this.input = { left: false, right: false, drop: false };
                this.target = null;
                this.score = 0;
                this.timeLeft = 60;
                this.timerInterval = null;
                this.isRunning = false;
                this.motorSound = null;
                this.isMuted = false;
                this.previousVolume = 0.5;

                this.setupInputs();
                this.setupVolume();
            }

            setupInputs() {
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft') this.input.left = true;
                    if (e.key === 'ArrowRight') this.input.right = true;
                    if (e.key === ' ' || e.key === 'ArrowDown') this.input.drop = true;
                });
                document.addEventListener('keyup', (e) => {
                    if (e.key === 'ArrowLeft') this.input.left = false;
                    if (e.key === 'ArrowRight') this.input.right = false;
                    if (e.key === ' ' || e.key === 'ArrowDown') this.input.drop = false;
                });

                document.getElementById('btn-left').addEventListener('mousedown', () => this.input.left = true);
                document.getElementById('btn-left').addEventListener('mouseup', () => this.input.left = false);
                document.getElementById('btn-right').addEventListener('mousedown', () => this.input.right = true);
                document.getElementById('btn-right').addEventListener('mouseup', () => this.input.right = false);
                document.getElementById('btn-drop').addEventListener('click', () => this.input.drop = true);
                // Reset drop input immediately after click to prevent loop
                document.getElementById('btn-drop').addEventListener('mouseup', () => setTimeout(() => this.input.drop = false, 100));
            }

            setupVolume() {
                const slider = document.getElementById('volume-slider');
                slider.addEventListener('input', (e) => {
                    this.setGlobalVolume(parseFloat(e.target.value));
                });
            }

            setGlobalVolume(val) {
                const icon = document.getElementById('mute-btn');

                if (this.isMuted) {
                    this.isMuted = false;
                    icon.textContent = "üîä";
                }

                const volume = val || 0.5;
                this.updateMuteIcon(volume);

                // Update motor gain if running
                if (this.motorSound) {
                    this.motorSound.gain.gain.setValueAtTime(0.05 * volume, audioCtx.currentTime);
                }
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                const icon = document.getElementById('mute-btn');
                const slider = document.getElementById('volume-slider');

                if (this.isMuted) {
                    this.previousVolume = parseFloat(slider.value);
                    // We don't change slider, just internal volume logic or mute the context/gain
                    // But here we rely on setGlobalVolume being called by slider.
                    // Let's just mute the bgMusic and future sounds.
                    bgMusic.volume = 0;
                    icon.textContent = "üîá";
                    if (this.motorSound) {
                        this.motorSound.gain.gain.setValueAtTime(0, audioCtx.currentTime);
                    }
                } else {
                    bgMusic.volume = slider.value * 0.5;
                    this.updateMuteIcon(parseFloat(slider.value));
                    if (this.motorSound) {
                        this.motorSound.gain.gain.setValueAtTime(0.05 * parseFloat(slider.value), audioCtx.currentTime);
                    }
                }
            }

            updateMuteIcon(val) {
                const icon = document.getElementById('mute-btn');
                if (val == 0) icon.textContent = "üîá";
                else if (val < 0.5) icon.textContent = "üîâ";
                else icon.textContent = "üîä";
            }


            start() {
                document.getElementById('start-screen').style.display = 'none';
                this.isRunning = true;
                this.score = 0;
                this.timeLeft = 60;
                this.balls = [];

                // Spawn Balls
                for (let i = 0; i < 12; i++) { // Reduced from 30 to 12
                    const data = FIGURES[Math.floor(Math.random() * FIGURES.length)];
                    this.balls.push(new Ball(
                        Math.random() * 800 + 50, // New width
                        Math.random() * 200 + 300, // Start lower
                        60, // Increased to 60 for better visibility
                        data
                    ));
                }

                this.setNewTarget();
                this.timerInterval = setInterval(() => this.tick(), 1000);
                this.loop();
            }

            setNewTarget() {
                // Ensure there is at least one ball to pick a target from
                if (this.balls.length === 0) {
                    this.target = { id: 'default', name: 'ATURA' };
                    document.getElementById('target-name').textContent = this.target.name;
                    return;
                }

                const randomBall = this.balls[Math.floor(Math.random() * this.balls.length)];
                this.target = randomBall.data;
                document.getElementById('target-name').textContent = this.target.name;
            }

            tick() {
                this.timeLeft--;
                document.getElementById('timer').textContent = this.timeLeft;
                if (this.timeLeft <= 0) {
                    this.gameOver();
                }
            }

            gameOver() {
                this.isRunning = false;
                clearInterval(this.timerInterval);
                document.getElementById('lose-modal').style.display = 'flex';
            }

            win() {
                this.isRunning = false;
                clearInterval(this.timerInterval);

                // Save Reward (Placeholder logic)
                const rewards = JSON.parse(sessionStorage.getItem('casinoRewards') || '{}');
                rewards['reward_gancho'] = true;
                sessionStorage.setItem('casinoRewards', JSON.stringify(rewards));

                document.getElementById('win-modal').style.display = 'flex';
                playWinSound();
            }

            checkCatch(ball) {
                if (ball.data.id === this.target.id) {
                    // Correct
                    this.score++;
                    document.getElementById('score').textContent = `${this.score}/5`;
                    playWinSound();

                    // Remove ball
                    const idx = this.balls.indexOf(ball);
                    if (idx > -1) this.balls.splice(idx, 1);

                    if (this.score >= 5) {
                        this.win();
                    } else {
                        this.setNewTarget();
                    }
                } else {
                    // Incorrect
                    playErrorSound();
                    // Ball falls back down (already released by claw)
                    ball.vy = 5; // Push down
                }
            }

            loop() {
                if (!this.isRunning) return;

                this.ctx.clearRect(0, 0, 900, 600);

                // Draw False Floor (Visual)
                this.ctx.fillStyle = '#222';
                this.ctx.fillRect(0, 450, 900, 150); // Raised floor
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.beginPath();
                this.ctx.moveTo(0, 450);
                this.ctx.lineTo(900, 450);
                this.ctx.stroke();

                // Update Claw
                this.claw.update(this.input, this.balls); // Pass balls for collision check

                // Motor Sound Logic
                if (this.claw.state !== 'IDLE' && !this.motorSound) {
                    this.motorSound = playMotor();
                } else if (this.claw.state === 'IDLE' && this.motorSound) {
                    stopMotor();
                    this.motorSound = null;
                }

                // Physics Steps
                for (let ball of this.balls) {
                    ball.update(this.gravity);
                }

                // Collisions (Ball-Ball)
                for (let i = 0; i < this.balls.length; i++) {
                    for (let j = i + 1; j < this.balls.length; j++) {
                        const b1 = this.balls[i];
                        const b2 = this.balls[j];
                        if (b1.isGrabbed || b2.isGrabbed) continue;

                        const dx = b2.x - b1.x;
                        const dy = b2.y - b1.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = b1.r + b2.r;

                        if (dist < minDist) {
                            // Resolve overlap
                            const angle = Math.atan2(dy, dx);
                            const tx = b1.x + Math.cos(angle) * minDist;
                            const ty = b1.y + Math.sin(angle) * minDist;
                            const ax = (tx - b2.x) * 0.1; // Spring force
                            const ay = (ty - b2.y) * 0.1;

                            b1.vx -= ax;
                            b1.vy -= ay;
                            b2.vx += ax;
                            b2.vy += ay;

                            // Friction
                            b1.vx *= 0.99;
                            b1.vy *= 0.99;
                            b2.vx *= 0.99;
                            b2.vy *= 0.99;
                        }
                    }
                }

                // Draw
                for (let ball of this.balls) {
                    ball.draw(this.ctx);
                }
                this.claw.draw(this.ctx);

                requestAnimationFrame(() => this.loop());
            }
        }

        const game = new Game();

    </script>
</body>

</html>